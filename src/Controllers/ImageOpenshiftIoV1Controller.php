<?php
/*
 * OpenShiftAPIWithKubernetesLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

namespace OpenShiftAPIWithKubernetesLib\Controllers;

use OpenShiftAPIWithKubernetesLib\APIException;
use OpenShiftAPIWithKubernetesLib\APIHelper;
use OpenShiftAPIWithKubernetesLib\Configuration;
use OpenShiftAPIWithKubernetesLib\Models;
use OpenShiftAPIWithKubernetesLib\Exceptions;
use OpenShiftAPIWithKubernetesLib\Http\HttpRequest;
use OpenShiftAPIWithKubernetesLib\Http\HttpResponse;
use OpenShiftAPIWithKubernetesLib\Http\HttpMethod;
use OpenShiftAPIWithKubernetesLib\Http\HttpContext;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class ImageOpenshiftIoV1Controller extends BaseController
{
    /**
     * @var ImageOpenshiftIoV1Controller The reference to *Singleton* instance of this class
     */
    private static $instance;

    /**
     * Returns the *Singleton* instance of this class.
     * @return ImageOpenshiftIoV1Controller The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * get available resources
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getImageOpenshiftIoV1APIResources()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1APIResourceList');
    }

    /**
     * list or watch objects of kind Image
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listImageOpenshiftIoV1Image(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/images';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageList');
    }

    /**
     * create an Image
     *
     * @param Models\V1Image $body   TODO: type description here
     * @param string         $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1Image(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/images';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Image');
    }

    /**
     * delete collection of Image
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteImageOpenshiftIoV1CollectionImage(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/images';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified Image
     *
     * @param string $name   name of the Image
     * @param bool   $exact  (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                       like 'Namespace'.
     * @param bool   $export (optional) Should this value be exported.  Export strips fields that a user can not
     *                       specify.
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadImageOpenshiftIoV1Image(
        $name,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/images/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'  => var_export($exact, true),
            'export' => var_export($export, true),
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Image');
    }

    /**
     * replace the specified Image
     *
     * @param Models\V1Image $body   TODO: type description here
     * @param string         $name   name of the Image
     * @param string         $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceImageOpenshiftIoV1Image(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/images/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Image');
    }

    /**
     * delete an Image
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Image
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteImageOpenshiftIoV1Image(
        $body,
        $name,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/images/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Image
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the Image
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchImageOpenshiftIoV1Image(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/images/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Image');
    }

    /**
     * create an ImageSignature
     *
     * @param Models\V1ImageSignature $body   TODO: type description here
     * @param string                  $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1ImageSignature(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/imagesignatures';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageSignature');
    }

    /**
     * delete an ImageSignature
     *
     * @param string $name   name of the ImageSignature
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteImageOpenshiftIoV1ImageSignature(
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/imagesignatures/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * create an ImageStreamImport
     *
     * @param Models\V1ImageStreamImport $body   TODO: type description here
     * @param string                     $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1ImageStreamImportForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/imagestreamimports';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamImport');
    }

    /**
     * create an ImageStreamMapping
     *
     * @param Models\V1ImageStreamMapping $body   TODO: type description here
     * @param string                      $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1ImageStreamMappingForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/imagestreammappings';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamMapping');
    }

    /**
     * list or watch objects of kind ImageStream
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listImageOpenshiftIoV1ImageStreamForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/imagestreams';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamList');
    }

    /**
     * create an ImageStream
     *
     * @param Models\V1ImageStream $body   TODO: type description here
     * @param string               $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1ImageStreamForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/imagestreams';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStream');
    }

    /**
     * list objects of kind ImageStreamTag
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listImageOpenshiftIoV1ImageStreamTagForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/imagestreamtags';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamTagList');
    }

    /**
     * create an ImageStreamTag
     *
     * @param Models\V1ImageStreamTag $body   TODO: type description here
     * @param string                  $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1ImageStreamTagForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/imagestreamtags';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamTag');
    }

    /**
     * read the specified ImageStreamImage
     *
     * @param string $name      name of the ImageStreamImage
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadImageOpenshiftIoV1NamespacedImageStreamImage(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreamimages/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamImage');
    }

    /**
     * create an ImageStreamImport
     *
     * @param Models\V1ImageStreamImport $body      TODO: type description here
     * @param string                     $mnamespace object name and auth scope, such as for teams and projects
     * @param string                     $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1NamespacedImageStreamImport(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreamimports';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamImport');
    }

    /**
     * create an ImageStreamMapping
     *
     * @param Models\V1ImageStreamMapping $body      TODO: type description here
     * @param string                      $mnamespace object name and auth scope, such as for teams and projects
     * @param string                      $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1NamespacedImageStreamMapping(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreammappings';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamMapping');
    }

    /**
     * list or watch objects of kind ImageStream
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listImageOpenshiftIoV1NamespacedImageStream(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamList');
    }

    /**
     * create an ImageStream
     *
     * @param Models\V1ImageStream $body      TODO: type description here
     * @param string               $mnamespace object name and auth scope, such as for teams and projects
     * @param string               $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1NamespacedImageStream(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStream');
    }

    /**
     * delete collection of ImageStream
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteImageOpenshiftIoV1CollectionNamespacedImageStream(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified ImageStream
     *
     * @param string $name      name of the ImageStream
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadImageOpenshiftIoV1NamespacedImageStream(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStream');
    }

    /**
     * replace the specified ImageStream
     *
     * @param Models\V1ImageStream $body      TODO: type description here
     * @param string               $name      name of the ImageStream
     * @param string               $mnamespace object name and auth scope, such as for teams and projects
     * @param string               $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceImageOpenshiftIoV1NamespacedImageStream(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStream');
    }

    /**
     * delete an ImageStream
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the ImageStream
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteImageOpenshiftIoV1NamespacedImageStream(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified ImageStream
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ImageStream
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchImageOpenshiftIoV1NamespacedImageStream(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStream');
    }

    /**
     * read secrets of the specified SecretList
     *
     * @param string  $name            name of the SecretList
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadImageOpenshiftIoV1NamespacedSecretListSecrets(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams/{name}/secrets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1SecretList');
    }

    /**
     * read status of the specified ImageStream
     *
     * @param string $name      name of the ImageStream
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadImageOpenshiftIoV1NamespacedImageStreamStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStream');
    }

    /**
     * replace status of the specified ImageStream
     *
     * @param Models\V1ImageStream $body      TODO: type description here
     * @param string               $name      name of the ImageStream
     * @param string               $mnamespace object name and auth scope, such as for teams and projects
     * @param string               $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceImageOpenshiftIoV1NamespacedImageStreamStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStream');
    }

    /**
     * partially update status of the specified ImageStream
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ImageStream
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchImageOpenshiftIoV1NamespacedImageStreamStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreams/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStream');
    }

    /**
     * list objects of kind ImageStreamTag
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listImageOpenshiftIoV1NamespacedImageStreamTag(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreamtags';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamTagList');
    }

    /**
     * create an ImageStreamTag
     *
     * @param Models\V1ImageStreamTag $body      TODO: type description here
     * @param string                  $mnamespace object name and auth scope, such as for teams and projects
     * @param string                  $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createImageOpenshiftIoV1NamespacedImageStreamTag(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreamtags';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamTag');
    }

    /**
     * read the specified ImageStreamTag
     *
     * @param string $name      name of the ImageStreamTag
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadImageOpenshiftIoV1NamespacedImageStreamTag(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreamtags/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamTag');
    }

    /**
     * replace the specified ImageStreamTag
     *
     * @param Models\V1ImageStreamTag $body      TODO: type description here
     * @param string                  $name      name of the ImageStreamTag
     * @param string                  $mnamespace object name and auth scope, such as for teams and projects
     * @param string                  $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceImageOpenshiftIoV1NamespacedImageStreamTag(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreamtags/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamTag');
    }

    /**
     * delete an ImageStreamTag
     *
     * @param string $name      name of the ImageStreamTag
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteImageOpenshiftIoV1NamespacedImageStreamTag(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreamtags/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified ImageStreamTag
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ImageStreamTag
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchImageOpenshiftIoV1NamespacedImageStreamTag(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/namespaces/{namespace}/imagestreamtags/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ImageStreamTag');
    }

    /**
     * watch individual changes to a list of Image
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchImageOpenshiftIoV1ImageList(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/watch/images';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Image
     *
     * @param string  $name            name of the Image
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchImageOpenshiftIoV1Image(
        $name,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/watch/images/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ImageStream
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchImageOpenshiftIoV1ImageStreamListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/image.openshift.io/v1/watch/imagestreams';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ImageStream
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchImageOpenshiftIoV1NamespacedImageStreamList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/watch/namespaces/{namespace}/imagestreams';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind ImageStream
     *
     * @param string  $name            name of the ImageStream
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchImageOpenshiftIoV1NamespacedImageStream(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/image.openshift.io/v1/watch/namespaces/{namespace}/imagestreams/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }
}
