<?php
/*
 * OpenShiftAPIWithKubernetesLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

namespace OpenShiftAPIWithKubernetesLib\Controllers;

use OpenShiftAPIWithKubernetesLib\APIException;
use OpenShiftAPIWithKubernetesLib\APIHelper;
use OpenShiftAPIWithKubernetesLib\Configuration;
use OpenShiftAPIWithKubernetesLib\Models;
use OpenShiftAPIWithKubernetesLib\Exceptions;
use OpenShiftAPIWithKubernetesLib\Http\HttpRequest;
use OpenShiftAPIWithKubernetesLib\Http\HttpResponse;
use OpenShiftAPIWithKubernetesLib\Http\HttpMethod;
use OpenShiftAPIWithKubernetesLib\Http\HttpContext;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class ExtensionsV1beta1Controller extends BaseController
{
    /**
     * @var ExtensionsV1beta1Controller The reference to *Singleton* instance of this class
     */
    private static $instance;

    /**
     * Returns the *Singleton* instance of this class.
     * @return ExtensionsV1beta1Controller The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * get available resources
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getExtensionsV1beta1APIResources()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1APIResourceList');
    }

    /**
     * list or watch objects of kind DaemonSet
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1DaemonSetForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/daemonsets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSetList');
    }

    /**
     * create a DaemonSet
     *
     * @param Models\V1beta1DaemonSet $body   TODO: type description here
     * @param string                  $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1DaemonSetForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/daemonsets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSet');
    }

    /**
     * list or watch objects of kind Deployment
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1DeploymentForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/deployments';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DeploymentList');
    }

    /**
     * create a Deployment
     *
     * @param Models\V1beta1Deployment $body   TODO: type description here
     * @param string                   $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1DeploymentForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/deployments';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Deployment');
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1HorizontalPodAutoscalerForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/horizontalpodautoscalers';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscalerList');
    }

    /**
     * create a HorizontalPodAutoscaler
     *
     * @param Models\V1beta1HorizontalPodAutoscaler $body   TODO: type description here
     * @param string                                $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1HorizontalPodAutoscalerForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/horizontalpodautoscalers';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscaler');
    }

    /**
     * list or watch objects of kind Ingress
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1IngressForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/ingresses';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1IngressList');
    }

    /**
     * create an Ingress
     *
     * @param Models\V1beta1Ingress $body   TODO: type description here
     * @param string                $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1IngressForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/ingresses';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Ingress');
    }

    /**
     * list or watch objects of kind DaemonSet
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1NamespacedDaemonSet(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSetList');
    }

    /**
     * create a DaemonSet
     *
     * @param Models\V1beta1DaemonSet $body      TODO: type description here
     * @param string                  $mnamespace object name and auth scope, such as for teams and projects
     * @param string                  $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1NamespacedDaemonSet(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSet');
    }

    /**
     * delete collection of DaemonSet
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1CollectionNamespacedDaemonSet(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified DaemonSet
     *
     * @param string $name      name of the DaemonSet
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedDaemonSet(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSet');
    }

    /**
     * replace the specified DaemonSet
     *
     * @param Models\V1beta1DaemonSet $body      TODO: type description here
     * @param string                  $name      name of the DaemonSet
     * @param string                  $mnamespace object name and auth scope, such as for teams and projects
     * @param string                  $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedDaemonSet(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSet');
    }

    /**
     * delete a DaemonSet
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the DaemonSet
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1NamespacedDaemonSet(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified DaemonSet
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the DaemonSet
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedDaemonSet(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSet');
    }

    /**
     * read status of the specified DaemonSet
     *
     * @param string $name      name of the DaemonSet
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedDaemonSetStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSet');
    }

    /**
     * replace status of the specified DaemonSet
     *
     * @param Models\V1beta1DaemonSet $body      TODO: type description here
     * @param string                  $name      name of the DaemonSet
     * @param string                  $mnamespace object name and auth scope, such as for teams and projects
     * @param string                  $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedDaemonSetStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSet');
    }

    /**
     * partially update status of the specified DaemonSet
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the DaemonSet
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedDaemonSetStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DaemonSet');
    }

    /**
     * list or watch objects of kind Deployment
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1NamespacedDeployment(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DeploymentList');
    }

    /**
     * create a Deployment
     *
     * @param Models\V1beta1Deployment $body      TODO: type description here
     * @param string                   $mnamespace object name and auth scope, such as for teams and projects
     * @param string                   $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1NamespacedDeployment(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Deployment');
    }

    /**
     * delete collection of Deployment
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1CollectionNamespacedDeployment(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified Deployment
     *
     * @param string $name      name of the Deployment
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedDeployment(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Deployment');
    }

    /**
     * replace the specified Deployment
     *
     * @param Models\V1beta1Deployment $body      TODO: type description here
     * @param string                   $name      name of the Deployment
     * @param string                   $mnamespace object name and auth scope, such as for teams and projects
     * @param string                   $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedDeployment(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Deployment');
    }

    /**
     * delete a Deployment
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Deployment
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1NamespacedDeployment(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Deployment
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Deployment
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedDeployment(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Deployment');
    }

    /**
     * create rollback of a DeploymentRollback
     *
     * @param Models\V1beta1DeploymentRollback $body      TODO: type description here
     * @param string                           $name      name of the DeploymentRollback
     * @param string                           $mnamespace object name and auth scope, such as for teams and projects
     * @param string                           $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1NamespacedDeploymentRollbackRollback(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/rollback';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1DeploymentRollback');
    }

    /**
     * read scale of the specified Scale
     *
     * @param string $name      name of the Scale
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedDeploymentsScale(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * replace scale of the specified Scale
     *
     * @param Models\V1beta1Scale $body      TODO: type description here
     * @param string              $name      name of the Scale
     * @param string              $mnamespace object name and auth scope, such as for teams and projects
     * @param string              $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedDeploymentsScale(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * partially update scale of the specified Scale
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Scale
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedDeploymentsScale(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * read status of the specified Deployment
     *
     * @param string $name      name of the Deployment
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedDeploymentStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Deployment');
    }

    /**
     * replace status of the specified Deployment
     *
     * @param Models\V1beta1Deployment $body      TODO: type description here
     * @param string                   $name      name of the Deployment
     * @param string                   $mnamespace object name and auth scope, such as for teams and projects
     * @param string                   $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedDeploymentStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Deployment');
    }

    /**
     * partially update status of the specified Deployment
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Deployment
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedDeploymentStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Deployment');
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1NamespacedHorizontalPodAutoscaler(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscalerList');
    }

    /**
     * create a HorizontalPodAutoscaler
     *
     * @param Models\V1beta1HorizontalPodAutoscaler $body      TODO: type description here
     * @param string                                $mnamespace object name and auth scope, such as for teams and
     *                                                         projects
     * @param string                                $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1NamespacedHorizontalPodAutoscaler(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscaler');
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1CollectionNamespacedHorizontalPodAutoscaler(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified HorizontalPodAutoscaler
     *
     * @param string $name      name of the HorizontalPodAutoscaler
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedHorizontalPodAutoscaler(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscaler');
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     *
     * @param Models\V1beta1HorizontalPodAutoscaler $body      TODO: type description here
     * @param string                                $name      name of the HorizontalPodAutoscaler
     * @param string                                $mnamespace object name and auth scope, such as for teams and
     *                                                         projects
     * @param string                                $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedHorizontalPodAutoscaler(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscaler');
    }

    /**
     * delete a HorizontalPodAutoscaler
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the HorizontalPodAutoscaler
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1NamespacedHorizontalPodAutoscaler(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the HorizontalPodAutoscaler
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedHorizontalPodAutoscaler(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscaler');
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     *
     * @param string $name      name of the HorizontalPodAutoscaler
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedHorizontalPodAutoscalerStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscaler');
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     *
     * @param Models\V1beta1HorizontalPodAutoscaler $body      TODO: type description here
     * @param string                                $name      name of the HorizontalPodAutoscaler
     * @param string                                $mnamespace object name and auth scope, such as for teams and
     *                                                         projects
     * @param string                                $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedHorizontalPodAutoscalerStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscaler');
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the HorizontalPodAutoscaler
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedHorizontalPodAutoscalerStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1HorizontalPodAutoscaler');
    }

    /**
     * list or watch objects of kind Ingress
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1NamespacedIngress(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/namespaces/{namespace}/ingresses';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1IngressList');
    }

    /**
     * create an Ingress
     *
     * @param Models\V1beta1Ingress $body      TODO: type description here
     * @param string                $mnamespace object name and auth scope, such as for teams and projects
     * @param string                $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1NamespacedIngress(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/namespaces/{namespace}/ingresses';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Ingress');
    }

    /**
     * delete collection of Ingress
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1CollectionNamespacedIngress(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/namespaces/{namespace}/ingresses';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified Ingress
     *
     * @param string $name      name of the Ingress
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedIngress(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Ingress');
    }

    /**
     * replace the specified Ingress
     *
     * @param Models\V1beta1Ingress $body      TODO: type description here
     * @param string                $name      name of the Ingress
     * @param string                $mnamespace object name and auth scope, such as for teams and projects
     * @param string                $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedIngress(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Ingress');
    }

    /**
     * delete an Ingress
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Ingress
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1NamespacedIngress(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Ingress
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Ingress
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedIngress(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Ingress');
    }

    /**
     * read status of the specified Ingress
     *
     * @param string $name      name of the Ingress
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedIngressStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Ingress');
    }

    /**
     * replace status of the specified Ingress
     *
     * @param Models\V1beta1Ingress $body      TODO: type description here
     * @param string                $name      name of the Ingress
     * @param string                $mnamespace object name and auth scope, such as for teams and projects
     * @param string                $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedIngressStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Ingress');
    }

    /**
     * partially update status of the specified Ingress
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Ingress
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedIngressStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Ingress');
    }

    /**
     * list or watch objects of kind NetworkPolicy
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1NamespacedNetworkPolicy(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1NetworkPolicyList');
    }

    /**
     * create a NetworkPolicy
     *
     * @param Models\V1beta1NetworkPolicy $body      TODO: type description here
     * @param string                      $mnamespace object name and auth scope, such as for teams and projects
     * @param string                      $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1NamespacedNetworkPolicy(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1NetworkPolicy');
    }

    /**
     * delete collection of NetworkPolicy
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1CollectionNamespacedNetworkPolicy(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified NetworkPolicy
     *
     * @param string $name      name of the NetworkPolicy
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedNetworkPolicy(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1NetworkPolicy');
    }

    /**
     * replace the specified NetworkPolicy
     *
     * @param Models\V1beta1NetworkPolicy $body      TODO: type description here
     * @param string                      $name      name of the NetworkPolicy
     * @param string                      $mnamespace object name and auth scope, such as for teams and projects
     * @param string                      $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedNetworkPolicy(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1NetworkPolicy');
    }

    /**
     * delete a NetworkPolicy
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the NetworkPolicy
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1NamespacedNetworkPolicy(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified NetworkPolicy
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the NetworkPolicy
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedNetworkPolicy(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1NetworkPolicy');
    }

    /**
     * list or watch objects of kind ReplicaSet
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1NamespacedReplicaSet(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSetList');
    }

    /**
     * create a ReplicaSet
     *
     * @param Models\V1beta1ReplicaSet $body      TODO: type description here
     * @param string                   $mnamespace object name and auth scope, such as for teams and projects
     * @param string                   $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1NamespacedReplicaSet(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSet');
    }

    /**
     * delete collection of ReplicaSet
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1CollectionNamespacedReplicaSet(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified ReplicaSet
     *
     * @param string $name      name of the ReplicaSet
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedReplicaSet(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSet');
    }

    /**
     * replace the specified ReplicaSet
     *
     * @param Models\V1beta1ReplicaSet $body      TODO: type description here
     * @param string                   $name      name of the ReplicaSet
     * @param string                   $mnamespace object name and auth scope, such as for teams and projects
     * @param string                   $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedReplicaSet(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSet');
    }

    /**
     * delete a ReplicaSet
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the ReplicaSet
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1NamespacedReplicaSet(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified ReplicaSet
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ReplicaSet
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedReplicaSet(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSet');
    }

    /**
     * read scale of the specified Scale
     *
     * @param string $name      name of the Scale
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedReplicasetsScale(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * replace scale of the specified Scale
     *
     * @param Models\V1beta1Scale $body      TODO: type description here
     * @param string              $name      name of the Scale
     * @param string              $mnamespace object name and auth scope, such as for teams and projects
     * @param string              $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedReplicasetsScale(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * partially update scale of the specified Scale
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Scale
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedReplicasetsScale(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * read status of the specified ReplicaSet
     *
     * @param string $name      name of the ReplicaSet
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedReplicaSetStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSet');
    }

    /**
     * replace status of the specified ReplicaSet
     *
     * @param Models\V1beta1ReplicaSet $body      TODO: type description here
     * @param string                   $name      name of the ReplicaSet
     * @param string                   $mnamespace object name and auth scope, such as for teams and projects
     * @param string                   $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedReplicaSetStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSet');
    }

    /**
     * partially update status of the specified ReplicaSet
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ReplicaSet
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedReplicaSetStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSet');
    }

    /**
     * read scale of the specified Scale
     *
     * @param string $name      name of the Scale
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1NamespacedReplicationcontrollersScale(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * replace scale of the specified Scale
     *
     * @param Models\V1beta1Scale $body      TODO: type description here
     * @param string              $name      name of the Scale
     * @param string              $mnamespace object name and auth scope, such as for teams and projects
     * @param string              $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1NamespacedReplicationcontrollersScale(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * partially update scale of the specified Scale
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Scale
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1NamespacedReplicationcontrollersScale(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Scale');
    }

    /**
     * list or watch objects of kind NetworkPolicy
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1NetworkPolicyForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/networkpolicies';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1NetworkPolicyList');
    }

    /**
     * create a NetworkPolicy
     *
     * @param Models\V1beta1NetworkPolicy $body   TODO: type description here
     * @param string                      $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1NetworkPolicyForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/networkpolicies';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1NetworkPolicy');
    }

    /**
     * list or watch objects of kind PodSecurityPolicy
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1PodSecurityPolicy(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/podsecuritypolicies';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1PodSecurityPolicyList');
    }

    /**
     * create a PodSecurityPolicy
     *
     * @param Models\V1beta1PodSecurityPolicy $body   TODO: type description here
     * @param string                          $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1PodSecurityPolicy(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/podsecuritypolicies';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1PodSecurityPolicy');
    }

    /**
     * delete collection of PodSecurityPolicy
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1CollectionPodSecurityPolicy(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/podsecuritypolicies';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified PodSecurityPolicy
     *
     * @param string $name   name of the PodSecurityPolicy
     * @param bool   $exact  (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                       like 'Namespace'.
     * @param bool   $export (optional) Should this value be exported.  Export strips fields that a user can not
     *                       specify.
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1PodSecurityPolicy(
        $name,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/podsecuritypolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'  => var_export($exact, true),
            'export' => var_export($export, true),
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1PodSecurityPolicy');
    }

    /**
     * replace the specified PodSecurityPolicy
     *
     * @param Models\V1beta1PodSecurityPolicy $body   TODO: type description here
     * @param string                          $name   name of the PodSecurityPolicy
     * @param string                          $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1PodSecurityPolicy(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/podsecuritypolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1PodSecurityPolicy');
    }

    /**
     * delete a PodSecurityPolicy
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the PodSecurityPolicy
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1PodSecurityPolicy(
        $body,
        $name,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/podsecuritypolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified PodSecurityPolicy
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the PodSecurityPolicy
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1PodSecurityPolicy(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/podsecuritypolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1PodSecurityPolicy');
    }

    /**
     * list or watch objects of kind ReplicaSet
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1ReplicaSetForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/replicasets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSetList');
    }

    /**
     * create a ReplicaSet
     *
     * @param Models\V1beta1ReplicaSet $body   TODO: type description here
     * @param string                   $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1ReplicaSetForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/replicasets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ReplicaSet');
    }

    /**
     * list or watch objects of kind ThirdPartyResource
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listExtensionsV1beta1ThirdPartyResource(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/thirdpartyresources';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ThirdPartyResourceList');
    }

    /**
     * create a ThirdPartyResource
     *
     * @param Models\V1beta1ThirdPartyResource $body   TODO: type description here
     * @param string                           $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createExtensionsV1beta1ThirdPartyResource(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/thirdpartyresources';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ThirdPartyResource');
    }

    /**
     * delete collection of ThirdPartyResource
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1CollectionThirdPartyResource(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/thirdpartyresources';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified ThirdPartyResource
     *
     * @param string $name   name of the ThirdPartyResource
     * @param bool   $exact  (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                       like 'Namespace'.
     * @param bool   $export (optional) Should this value be exported.  Export strips fields that a user can not
     *                       specify.
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadExtensionsV1beta1ThirdPartyResource(
        $name,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/thirdpartyresources/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'  => var_export($exact, true),
            'export' => var_export($export, true),
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ThirdPartyResource');
    }

    /**
     * replace the specified ThirdPartyResource
     *
     * @param Models\V1beta1ThirdPartyResource $body   TODO: type description here
     * @param string                           $name   name of the ThirdPartyResource
     * @param string                           $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceExtensionsV1beta1ThirdPartyResource(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/thirdpartyresources/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ThirdPartyResource');
    }

    /**
     * delete a ThirdPartyResource
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the ThirdPartyResource
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteExtensionsV1beta1ThirdPartyResource(
        $body,
        $name,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/thirdpartyresources/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified ThirdPartyResource
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the ThirdPartyResource
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchExtensionsV1beta1ThirdPartyResource(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/thirdpartyresources/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1ThirdPartyResource');
    }

    /**
     * watch individual changes to a list of DaemonSet
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1DaemonSetListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/daemonsets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Deployment
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1DeploymentListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/deployments';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of HorizontalPodAutoscaler
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1HorizontalPodAutoscalerListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/horizontalpodautoscalers';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Ingress
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1IngressListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/ingresses';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of DaemonSet
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedDaemonSetList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/daemonsets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind DaemonSet
     *
     * @param string  $name            name of the DaemonSet
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedDaemonSet(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/daemonsets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Deployment
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedDeploymentList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/deployments';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Deployment
     *
     * @param string  $name            name of the Deployment
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedDeployment(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/deployments/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of HorizontalPodAutoscaler
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedHorizontalPodAutoscalerList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/horizontalpodautoscalers';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind HorizontalPodAutoscaler
     *
     * @param string  $name            name of the HorizontalPodAutoscaler
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedHorizontalPodAutoscaler(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/horizontalpodautoscalers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Ingress
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedIngressList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/ingresses';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Ingress
     *
     * @param string  $name            name of the Ingress
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedIngress(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/ingresses/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of NetworkPolicy
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedNetworkPolicyList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/networkpolicies';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind NetworkPolicy
     *
     * @param string  $name            name of the NetworkPolicy
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedNetworkPolicy(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/networkpolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ReplicaSet
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedReplicaSetList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/replicasets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind ReplicaSet
     *
     * @param string  $name            name of the ReplicaSet
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NamespacedReplicaSet(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/apis/extensions/v1beta1/watch/namespaces/{namespace}/replicasets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of NetworkPolicy
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1NetworkPolicyListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/networkpolicies';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of PodSecurityPolicy
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1PodSecurityPolicyList(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/podsecuritypolicies';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind PodSecurityPolicy
     *
     * @param string  $name            name of the PodSecurityPolicy
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1PodSecurityPolicy(
        $name,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/podsecuritypolicies/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ReplicaSet
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1ReplicaSetListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/replicasets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ThirdPartyResource
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1ThirdPartyResourceList(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/thirdpartyresources';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind ThirdPartyResource
     *
     * @param string  $name            name of the ThirdPartyResource
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchExtensionsV1beta1ThirdPartyResource(
        $name,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/apis/extensions/v1beta1/watch/thirdpartyresources/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }
}
