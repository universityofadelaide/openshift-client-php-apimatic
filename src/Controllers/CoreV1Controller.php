<?php
/*
 * OpenShiftAPIWithKubernetesLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

namespace OpenShiftAPIWithKubernetesLib\Controllers;

use OpenShiftAPIWithKubernetesLib\APIException;
use OpenShiftAPIWithKubernetesLib\APIHelper;
use OpenShiftAPIWithKubernetesLib\Configuration;
use OpenShiftAPIWithKubernetesLib\Models;
use OpenShiftAPIWithKubernetesLib\Exceptions;
use OpenShiftAPIWithKubernetesLib\Http\HttpRequest;
use OpenShiftAPIWithKubernetesLib\Http\HttpResponse;
use OpenShiftAPIWithKubernetesLib\Http\HttpMethod;
use OpenShiftAPIWithKubernetesLib\Http\HttpContext;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class CoreV1Controller extends BaseController
{
    /**
     * @var CoreV1Controller The reference to *Singleton* instance of this class
     */
    private static $instance;

    /**
     * Returns the *Singleton* instance of this class.
     * @return CoreV1Controller The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * get available resources
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getCoreV1APIResources()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1APIResourceList');
    }

    /**
     * create a Binding
     *
     * @param Models\V1Binding $body   TODO: type description here
     * @param string           $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1BindingForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/bindings';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Binding');
    }

    /**
     * list objects of kind ComponentStatus
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1ComponentStatus(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/componentstatuses';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ComponentStatusList');
    }

    /**
     * read the specified ComponentStatus
     *
     * @param string $name   name of the ComponentStatus
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1ComponentStatus(
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/componentstatuses/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ComponentStatus');
    }

    /**
     * list or watch objects of kind ConfigMap
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1ConfigMapForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/configmaps';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ConfigMapList');
    }

    /**
     * create a ConfigMap
     *
     * @param Models\V1ConfigMap $body   TODO: type description here
     * @param string             $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1ConfigMapForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/configmaps';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ConfigMap');
    }

    /**
     * list or watch objects of kind Endpoints
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1EndpointsForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/endpoints';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1EndpointsList');
    }

    /**
     * create Endpoints
     *
     * @param Models\V1Endpoints $body   TODO: type description here
     * @param string             $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1EndpointsForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/endpoints';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Endpoints');
    }

    /**
     * list or watch objects of kind Event
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1EventForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/events';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1EventList');
    }

    /**
     * create an Event
     *
     * @param Models\V1Event $body   TODO: type description here
     * @param string         $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1EventForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/events';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Event');
    }

    /**
     * list or watch objects of kind LimitRange
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1LimitRangeForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/limitranges';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1LimitRangeList');
    }

    /**
     * create a LimitRange
     *
     * @param Models\V1LimitRange $body   TODO: type description here
     * @param string              $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1LimitRangeForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/limitranges';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1LimitRange');
    }

    /**
     * list or watch objects of kind Namespace
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1Namespace(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1NamespaceList');
    }

    /**
     * create a Namespace
     *
     * @param Models\V1Namespace $body   TODO: type description here
     * @param string             $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1Namespace(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Namespace');
    }

    /**
     * delete collection of Namespace
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespace(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * create a Binding
     *
     * @param Models\V1Binding $body      TODO: type description here
     * @param string           $mnamespace object name and auth scope, such as for teams and projects
     * @param string           $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedBinding(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/bindings';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Binding');
    }

    /**
     * list or watch objects of kind ConfigMap
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedConfigMap(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/configmaps';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ConfigMapList');
    }

    /**
     * create a ConfigMap
     *
     * @param Models\V1ConfigMap $body      TODO: type description here
     * @param string             $mnamespace object name and auth scope, such as for teams and projects
     * @param string             $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedConfigMap(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/configmaps';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ConfigMap');
    }

    /**
     * delete collection of ConfigMap
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedConfigMap(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/configmaps';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified ConfigMap
     *
     * @param string $name      name of the ConfigMap
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedConfigMap(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/configmaps/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ConfigMap');
    }

    /**
     * replace the specified ConfigMap
     *
     * @param Models\V1ConfigMap $body      TODO: type description here
     * @param string             $name      name of the ConfigMap
     * @param string             $mnamespace object name and auth scope, such as for teams and projects
     * @param string             $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedConfigMap(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/configmaps/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ConfigMap');
    }

    /**
     * delete a ConfigMap
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the ConfigMap
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedConfigMap(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/configmaps/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified ConfigMap
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ConfigMap
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedConfigMap(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/configmaps/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ConfigMap');
    }

    /**
     * list or watch objects of kind Endpoints
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedEndpoints(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/endpoints';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1EndpointsList');
    }

    /**
     * create Endpoints
     *
     * @param Models\V1Endpoints $body      TODO: type description here
     * @param string             $mnamespace object name and auth scope, such as for teams and projects
     * @param string             $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedEndpoints(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/endpoints';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Endpoints');
    }

    /**
     * delete collection of Endpoints
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedEndpoints(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/endpoints';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified Endpoints
     *
     * @param string $name      name of the Endpoints
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedEndpoints(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/endpoints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Endpoints');
    }

    /**
     * replace the specified Endpoints
     *
     * @param Models\V1Endpoints $body      TODO: type description here
     * @param string             $name      name of the Endpoints
     * @param string             $mnamespace object name and auth scope, such as for teams and projects
     * @param string             $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedEndpoints(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/endpoints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Endpoints');
    }

    /**
     * delete Endpoints
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Endpoints
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedEndpoints(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/endpoints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Endpoints
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Endpoints
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedEndpoints(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/endpoints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Endpoints');
    }

    /**
     * list or watch objects of kind Event
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedEvent(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/events';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1EventList');
    }

    /**
     * create an Event
     *
     * @param Models\V1Event $body      TODO: type description here
     * @param string         $mnamespace object name and auth scope, such as for teams and projects
     * @param string         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedEvent(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/events';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Event');
    }

    /**
     * delete collection of Event
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedEvent(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/events';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified Event
     *
     * @param string $name      name of the Event
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedEvent(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/events/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Event');
    }

    /**
     * replace the specified Event
     *
     * @param Models\V1Event $body      TODO: type description here
     * @param string         $name      name of the Event
     * @param string         $mnamespace object name and auth scope, such as for teams and projects
     * @param string         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedEvent(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/events/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Event');
    }

    /**
     * delete an Event
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Event
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedEvent(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/events/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Event
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Event
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedEvent(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/events/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Event');
    }

    /**
     * list or watch objects of kind LimitRange
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedLimitRange(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/limitranges';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1LimitRangeList');
    }

    /**
     * create a LimitRange
     *
     * @param Models\V1LimitRange $body      TODO: type description here
     * @param string              $mnamespace object name and auth scope, such as for teams and projects
     * @param string              $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedLimitRange(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/limitranges';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1LimitRange');
    }

    /**
     * delete collection of LimitRange
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedLimitRange(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/limitranges';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified LimitRange
     *
     * @param string $name      name of the LimitRange
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedLimitRange(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/limitranges/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1LimitRange');
    }

    /**
     * replace the specified LimitRange
     *
     * @param Models\V1LimitRange $body      TODO: type description here
     * @param string              $name      name of the LimitRange
     * @param string              $mnamespace object name and auth scope, such as for teams and projects
     * @param string              $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedLimitRange(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/limitranges/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1LimitRange');
    }

    /**
     * delete a LimitRange
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the LimitRange
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedLimitRange(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/limitranges/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified LimitRange
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the LimitRange
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedLimitRange(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/limitranges/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1LimitRange');
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedPersistentVolumeClaim(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/persistentvolumeclaims';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaimList');
    }

    /**
     * create a PersistentVolumeClaim
     *
     * @param Models\V1PersistentVolumeClaim $body      TODO: type description here
     * @param string                         $mnamespace object name and auth scope, such as for teams and projects
     * @param string                         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedPersistentVolumeClaim(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/persistentvolumeclaims';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaim');
    }

    /**
     * delete collection of PersistentVolumeClaim
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedPersistentVolumeClaim(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/persistentvolumeclaims';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified PersistentVolumeClaim
     *
     * @param string $name      name of the PersistentVolumeClaim
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedPersistentVolumeClaim(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaim');
    }

    /**
     * replace the specified PersistentVolumeClaim
     *
     * @param Models\V1PersistentVolumeClaim $body      TODO: type description here
     * @param string                         $name      name of the PersistentVolumeClaim
     * @param string                         $mnamespace object name and auth scope, such as for teams and projects
     * @param string                         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedPersistentVolumeClaim(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaim');
    }

    /**
     * delete a PersistentVolumeClaim
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the PersistentVolumeClaim
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedPersistentVolumeClaim(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified PersistentVolumeClaim
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the PersistentVolumeClaim
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedPersistentVolumeClaim(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaim');
    }

    /**
     * read status of the specified PersistentVolumeClaim
     *
     * @param string $name      name of the PersistentVolumeClaim
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedPersistentVolumeClaimStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaim');
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     *
     * @param Models\V1PersistentVolumeClaim $body      TODO: type description here
     * @param string                         $name      name of the PersistentVolumeClaim
     * @param string                         $mnamespace object name and auth scope, such as for teams and projects
     * @param string                         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedPersistentVolumeClaimStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaim');
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the PersistentVolumeClaim
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedPersistentVolumeClaimStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaim');
    }

    /**
     * list or watch objects of kind Pod
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedPod(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodList');
    }

    /**
     * create a Pod
     *
     * @param Models\V1Pod $body      TODO: type description here
     * @param string       $mnamespace object name and auth scope, such as for teams and projects
     * @param string       $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedPod(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Pod');
    }

    /**
     * delete collection of Pod
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedPod(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedPod(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Pod');
    }

    /**
     * replace the specified Pod
     *
     * @param Models\V1Pod $body      TODO: type description here
     * @param string       $name      name of the Pod
     * @param string       $mnamespace object name and auth scope, such as for teams and projects
     * @param string       $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedPod(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Pod');
    }

    /**
     * delete a Pod
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Pod
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedPod(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Pod
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedPod(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Pod');
    }

    /**
     * connect GET requests to attach of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $container (optional) The container in which to execute the command. Defaults to only container if
     *                          there is only one container in the pod.
     * @param bool   $stderr    (optional) Stderr if true indicates that stderr is to be redirected for the attach call.
     *                          Defaults to true.
     * @param bool   $stdin     (optional) Stdin if true, redirects the standard input stream of the pod for this call.
     *                          Defaults to false.
     * @param bool   $stdout    (optional) Stdout if true indicates that stdout is to be redirected for the attach call.
     *                          Defaults to true.
     * @param bool   $tty       (optional) TTY if true indicates that a tty will be allocated for the attach call. This
     *                          is passed through the container runtime so the tty is allocated on the worker node by
     *                          the container runtime. Defaults to false.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNamespacedPodAttach(
        $name,
        $mnamespace,
        $container = null,
        $stderr = null,
        $stdin = null,
        $stdout = null,
        $tty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/attach';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'container' => $container,
            'stderr'    => var_export($stderr, true),
            'stdin'     => var_export($stdin, true),
            'stdout'    => var_export($stdout, true),
            'tty'       => var_export($tty, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to attach of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $container (optional) The container in which to execute the command. Defaults to only container if
     *                          there is only one container in the pod.
     * @param bool   $stderr    (optional) Stderr if true indicates that stderr is to be redirected for the attach call.
     *                          Defaults to true.
     * @param bool   $stdin     (optional) Stdin if true, redirects the standard input stream of the pod for this call.
     *                          Defaults to false.
     * @param bool   $stdout    (optional) Stdout if true indicates that stdout is to be redirected for the attach call.
     *                          Defaults to true.
     * @param bool   $tty       (optional) TTY if true indicates that a tty will be allocated for the attach call. This
     *                          is passed through the container runtime so the tty is allocated on the worker node by
     *                          the container runtime. Defaults to false.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNamespacedPodAttach(
        $name,
        $mnamespace,
        $container = null,
        $stderr = null,
        $stdin = null,
        $stdout = null,
        $tty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/attach';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'container' => $container,
            'stderr'    => var_export($stderr, true),
            'stdin'     => var_export($stdin, true),
            'stdout'    => var_export($stdout, true),
            'tty'       => var_export($tty, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * create binding of a Binding
     *
     * @param Models\V1Binding $body      TODO: type description here
     * @param string           $name      name of the Binding
     * @param string           $mnamespace object name and auth scope, such as for teams and projects
     * @param string           $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedBindingBinding(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/binding';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Binding');
    }

    /**
     * create eviction of an Eviction
     *
     * @param Models\V1beta1Eviction $body      TODO: type description here
     * @param string                 $name      name of the Eviction
     * @param string                 $mnamespace object name and auth scope, such as for teams and projects
     * @param string                 $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedEvictionEviction(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/eviction';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1beta1Eviction');
    }

    /**
     * connect GET requests to exec of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $command   (optional) Command is the remote command to execute. argv array. Not executed within a
     *                          shell.
     * @param string $container (optional) Container in which to execute the command. Defaults to only container if
     *                          there is only one container in the pod.
     * @param bool   $stderr    (optional) Redirect the standard error stream of the pod for this call. Defaults to
     *                          true.
     * @param bool   $stdin     (optional) Redirect the standard input stream of the pod for this call. Defaults to
     *                          false.
     * @param bool   $stdout    (optional) Redirect the standard output stream of the pod for this call. Defaults to
     *                          true.
     * @param bool   $tty       (optional) TTY if true indicates that a tty will be allocated for the exec call.
     *                          Defaults to false.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNamespacedPodExec(
        $name,
        $mnamespace,
        $command = null,
        $container = null,
        $stderr = null,
        $stdin = null,
        $stdout = null,
        $tty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/exec';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'command'   => $command,
            'container' => $container,
            'stderr'    => var_export($stderr, true),
            'stdin'     => var_export($stdin, true),
            'stdout'    => var_export($stdout, true),
            'tty'       => var_export($tty, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to exec of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $command   (optional) Command is the remote command to execute. argv array. Not executed within a
     *                          shell.
     * @param string $container (optional) Container in which to execute the command. Defaults to only container if
     *                          there is only one container in the pod.
     * @param bool   $stderr    (optional) Redirect the standard error stream of the pod for this call. Defaults to
     *                          true.
     * @param bool   $stdin     (optional) Redirect the standard input stream of the pod for this call. Defaults to
     *                          false.
     * @param bool   $stdout    (optional) Redirect the standard output stream of the pod for this call. Defaults to
     *                          true.
     * @param bool   $tty       (optional) TTY if true indicates that a tty will be allocated for the exec call.
     *                          Defaults to false.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNamespacedPodExec(
        $name,
        $mnamespace,
        $command = null,
        $container = null,
        $stderr = null,
        $stdin = null,
        $stdout = null,
        $tty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/exec';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'command'   => $command,
            'container' => $container,
            'stderr'    => var_export($stderr, true),
            'stdin'     => var_export($stdin, true),
            'stdout'    => var_export($stdout, true),
            'tty'       => var_export($tty, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * read log of the specified Pod
     *
     * @param string  $name         name of the Pod
     * @param string  $mnamespace   object name and auth scope, such as for teams and projects
     * @param string  $container    (optional) The container for which to stream logs. Defaults to only container if
     *                              there is one container in the pod.
     * @param bool    $follow       (optional) Follow the log stream of the pod. Defaults to false.
     * @param integer $limitBytes   (optional) If set, the number of bytes to read from the server before terminating
     *                              the log output. This may not display a complete final line of logging, and may
     *                              return slightly more or slightly less than the specified limit.
     * @param string  $pretty       (optional) If 'true', then the output is pretty printed.
     * @param bool    $previous     (optional) Return previous terminated container logs. Defaults to false.
     * @param integer $sinceSeconds (optional) A relative time in seconds before the current time from which to show
     *                              logs. If this value precedes the time a pod was started, only logs since the pod
     *                              start will be returned. If this value is in the future, no logs will be returned.
     *                              Only one of sinceSeconds or sinceTime may be specified.
     * @param integer $tailLines    (optional) If set, the number of lines from the end of the logs to show. If not
     *                              specified, logs are shown from the creation of the container or sinceSeconds or
     *                              sinceTime
     * @param bool    $timestamps   (optional) If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of
     *                              every line of log output. Defaults to false.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedPodLog(
        $name,
        $mnamespace,
        $container = null,
        $follow = null,
        $limitBytes = null,
        $pretty = null,
        $previous = null,
        $sinceSeconds = null,
        $tailLines = null,
        $timestamps = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/log';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'         => $name,
            'namespace'    => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'container'    => $container,
            'follow'       => var_export($follow, true),
            'limitBytes'   => $limitBytes,
            'pretty'       => $pretty,
            'previous'     => var_export($previous, true),
            'sinceSeconds' => $sinceSeconds,
            'tailLines'    => $tailLines,
            'timestamps'   => var_export($timestamps, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect GET requests to portforward of Pod
     *
     * @param string  $name      name of the Pod
     * @param string  $mnamespace object name and auth scope, such as for teams and projects
     * @param integer $ports     (optional) List of ports to forward Required when using WebSockets
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNamespacedPodPortforward(
        $name,
        $mnamespace,
        $ports = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/portforward';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'ports'     => $ports,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to portforward of Pod
     *
     * @param string  $name      name of the Pod
     * @param string  $mnamespace object name and auth scope, such as for teams and projects
     * @param integer $ports     (optional) List of ports to forward Required when using WebSockets
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNamespacedPodPortforward(
        $name,
        $mnamespace,
        $ports = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/portforward';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'ports'     => $ports,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect GET requests to proxy of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      (optional) Path is the URL path to use for the current proxy request to pod.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNamespacedPodProxy(
        $name,
        $mnamespace,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'      => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect PUT requests to proxy of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      (optional) Path is the URL path to use for the current proxy request to pod.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateConnectCoreV1PutNamespacedPodProxy(
        $name,
        $mnamespace,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'      => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to proxy of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      (optional) Path is the URL path to use for the current proxy request to pod.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNamespacedPodProxy(
        $name,
        $mnamespace,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'      => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect DELETE requests to proxy of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      (optional) Path is the URL path to use for the current proxy request to pod.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteConnectCoreV1DeleteNamespacedPodProxy(
        $name,
        $mnamespace,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'      => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect GET requests to proxy of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNamespacedPodProxyWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect PUT requests to proxy of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateConnectCoreV1PutNamespacedPodProxyWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to proxy of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNamespacedPodProxyWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect DELETE requests to proxy of Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteConnectCoreV1DeleteNamespacedPodProxyWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * read status of the specified Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedPodStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Pod');
    }

    /**
     * replace status of the specified Pod
     *
     * @param Models\V1Pod $body      TODO: type description here
     * @param string       $name      name of the Pod
     * @param string       $mnamespace object name and auth scope, such as for teams and projects
     * @param string       $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedPodStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Pod');
    }

    /**
     * partially update status of the specified Pod
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedPodStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/pods/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Pod');
    }

    /**
     * list or watch objects of kind PodTemplate
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedPodTemplate(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/podtemplates';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodTemplateList');
    }

    /**
     * create a PodTemplate
     *
     * @param Models\V1PodTemplate $body      TODO: type description here
     * @param string               $mnamespace object name and auth scope, such as for teams and projects
     * @param string               $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedPodTemplate(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/podtemplates';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodTemplate');
    }

    /**
     * delete collection of PodTemplate
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedPodTemplate(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/podtemplates';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified PodTemplate
     *
     * @param string $name      name of the PodTemplate
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedPodTemplate(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/podtemplates/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodTemplate');
    }

    /**
     * replace the specified PodTemplate
     *
     * @param Models\V1PodTemplate $body      TODO: type description here
     * @param string               $name      name of the PodTemplate
     * @param string               $mnamespace object name and auth scope, such as for teams and projects
     * @param string               $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedPodTemplate(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/podtemplates/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodTemplate');
    }

    /**
     * delete a PodTemplate
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the PodTemplate
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedPodTemplate(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/podtemplates/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified PodTemplate
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the PodTemplate
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedPodTemplate(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/podtemplates/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodTemplate');
    }

    /**
     * list or watch objects of kind ReplicationController
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedReplicationController(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/replicationcontrollers';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationControllerList');
    }

    /**
     * create a ReplicationController
     *
     * @param Models\V1ReplicationController $body      TODO: type description here
     * @param string                         $mnamespace object name and auth scope, such as for teams and projects
     * @param string                         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedReplicationController(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/replicationcontrollers';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationController');
    }

    /**
     * delete collection of ReplicationController
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedReplicationController(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/replicationcontrollers';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified ReplicationController
     *
     * @param string $name      name of the ReplicationController
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedReplicationController(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationController');
    }

    /**
     * replace the specified ReplicationController
     *
     * @param Models\V1ReplicationController $body      TODO: type description here
     * @param string                         $name      name of the ReplicationController
     * @param string                         $mnamespace object name and auth scope, such as for teams and projects
     * @param string                         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedReplicationController(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationController');
    }

    /**
     * delete a ReplicationController
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the ReplicationController
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedReplicationController(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified ReplicationController
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ReplicationController
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedReplicationController(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationController');
    }

    /**
     * read scale of the specified Scale
     *
     * @param string $name      name of the Scale
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedScaleScale(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Scale');
    }

    /**
     * replace scale of the specified Scale
     *
     * @param Models\V1Scale $body      TODO: type description here
     * @param string         $name      name of the Scale
     * @param string         $mnamespace object name and auth scope, such as for teams and projects
     * @param string         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedScaleScale(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Scale');
    }

    /**
     * partially update scale of the specified Scale
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Scale
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedScaleScale(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Scale');
    }

    /**
     * read status of the specified ReplicationController
     *
     * @param string $name      name of the ReplicationController
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedReplicationControllerStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationController');
    }

    /**
     * replace status of the specified ReplicationController
     *
     * @param Models\V1ReplicationController $body      TODO: type description here
     * @param string                         $name      name of the ReplicationController
     * @param string                         $mnamespace object name and auth scope, such as for teams and projects
     * @param string                         $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedReplicationControllerStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationController');
    }

    /**
     * partially update status of the specified ReplicationController
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ReplicationController
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedReplicationControllerStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationController');
    }

    /**
     * list or watch objects of kind ResourceQuota
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedResourceQuota(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/resourcequotas';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuotaList');
    }

    /**
     * create a ResourceQuota
     *
     * @param Models\V1ResourceQuota $body      TODO: type description here
     * @param string                 $mnamespace object name and auth scope, such as for teams and projects
     * @param string                 $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedResourceQuota(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/resourcequotas';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuota');
    }

    /**
     * delete collection of ResourceQuota
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedResourceQuota(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/resourcequotas';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified ResourceQuota
     *
     * @param string $name      name of the ResourceQuota
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedResourceQuota(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/resourcequotas/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuota');
    }

    /**
     * replace the specified ResourceQuota
     *
     * @param Models\V1ResourceQuota $body      TODO: type description here
     * @param string                 $name      name of the ResourceQuota
     * @param string                 $mnamespace object name and auth scope, such as for teams and projects
     * @param string                 $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedResourceQuota(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/resourcequotas/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuota');
    }

    /**
     * delete a ResourceQuota
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the ResourceQuota
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedResourceQuota(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/resourcequotas/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified ResourceQuota
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ResourceQuota
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedResourceQuota(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/resourcequotas/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuota');
    }

    /**
     * read status of the specified ResourceQuota
     *
     * @param string $name      name of the ResourceQuota
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedResourceQuotaStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuota');
    }

    /**
     * replace status of the specified ResourceQuota
     *
     * @param Models\V1ResourceQuota $body      TODO: type description here
     * @param string                 $name      name of the ResourceQuota
     * @param string                 $mnamespace object name and auth scope, such as for teams and projects
     * @param string                 $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedResourceQuotaStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuota');
    }

    /**
     * partially update status of the specified ResourceQuota
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ResourceQuota
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedResourceQuotaStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuota');
    }

    /**
     * list or watch objects of kind Secret
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedSecret(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/secrets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1SecretList');
    }

    /**
     * create a Secret
     *
     * @param Models\V1Secret $body      TODO: type description here
     * @param string          $mnamespace object name and auth scope, such as for teams and projects
     * @param string          $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedSecret(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/secrets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Secret');
    }

    /**
     * delete collection of Secret
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedSecret(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/secrets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified Secret
     *
     * @param string $name      name of the Secret
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedSecret(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/secrets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Secret');
    }

    /**
     * replace the specified Secret
     *
     * @param Models\V1Secret $body      TODO: type description here
     * @param string          $name      name of the Secret
     * @param string          $mnamespace object name and auth scope, such as for teams and projects
     * @param string          $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedSecret(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/secrets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Secret');
    }

    /**
     * delete a Secret
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Secret
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedSecret(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/secrets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Secret
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Secret
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedSecret(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/secrets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Secret');
    }

    /**
     * list or watch objects of kind ServiceAccount
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedServiceAccount(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/serviceaccounts';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceAccountList');
    }

    /**
     * create a ServiceAccount
     *
     * @param Models\V1ServiceAccount $body      TODO: type description here
     * @param string                  $mnamespace object name and auth scope, such as for teams and projects
     * @param string                  $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedServiceAccount(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/serviceaccounts';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceAccount');
    }

    /**
     * delete collection of ServiceAccount
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNamespacedServiceAccount(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/serviceaccounts';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified ServiceAccount
     *
     * @param string $name      name of the ServiceAccount
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedServiceAccount(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/serviceaccounts/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceAccount');
    }

    /**
     * replace the specified ServiceAccount
     *
     * @param Models\V1ServiceAccount $body      TODO: type description here
     * @param string                  $name      name of the ServiceAccount
     * @param string                  $mnamespace object name and auth scope, such as for teams and projects
     * @param string                  $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedServiceAccount(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/serviceaccounts/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceAccount');
    }

    /**
     * delete a ServiceAccount
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the ServiceAccount
     * @param string                 $mnamespace         object name and auth scope, such as for teams and projects
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedServiceAccount(
        $body,
        $name,
        $mnamespace,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/serviceaccounts/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            'namespace'          => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified ServiceAccount
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the ServiceAccount
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedServiceAccount(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/serviceaccounts/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceAccount');
    }

    /**
     * list or watch objects of kind Service
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1NamespacedService(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceList');
    }

    /**
     * create a Service
     *
     * @param Models\V1Service $body      TODO: type description here
     * @param string           $mnamespace object name and auth scope, such as for teams and projects
     * @param string           $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1NamespacedService(
        $body,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Service');
    }

    /**
     * read the specified Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param bool   $exact     (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                          like 'Namespace'.
     * @param bool   $export    (optional) Should this value be exported.  Export strips fields that a user can not
     *                          specify.
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedService(
        $name,
        $mnamespace,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'     => var_export($exact, true),
            'export'    => var_export($export, true),
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Service');
    }

    /**
     * replace the specified Service
     *
     * @param Models\V1Service $body      TODO: type description here
     * @param string           $name      name of the Service
     * @param string           $mnamespace object name and auth scope, such as for teams and projects
     * @param string           $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedService(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Service');
    }

    /**
     * delete a Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1NamespacedService(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Service
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedService(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Service');
    }

    /**
     * connect GET requests to proxy of Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      (optional) Path is the part of URLs that include service endpoints, suffixes, and
     *                          parameters to use for the current proxy request to service. For example, the whole
     *                          request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-
     *                          logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNamespacedServiceProxy(
        $name,
        $mnamespace,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'      => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect PUT requests to proxy of Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      (optional) Path is the part of URLs that include service endpoints, suffixes, and
     *                          parameters to use for the current proxy request to service. For example, the whole
     *                          request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-
     *                          logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateConnectCoreV1PutNamespacedServiceProxy(
        $name,
        $mnamespace,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'      => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to proxy of Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      (optional) Path is the part of URLs that include service endpoints, suffixes, and
     *                          parameters to use for the current proxy request to service. For example, the whole
     *                          request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-
     *                          logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNamespacedServiceProxy(
        $name,
        $mnamespace,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'      => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect DELETE requests to proxy of Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      (optional) Path is the part of URLs that include service endpoints, suffixes, and
     *                          parameters to use for the current proxy request to service. For example, the whole
     *                          request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-
     *                          logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteConnectCoreV1DeleteNamespacedServiceProxy(
        $name,
        $mnamespace,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'      => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect GET requests to proxy of Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNamespacedServiceProxyWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect PUT requests to proxy of Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateConnectCoreV1PutNamespacedServiceProxyWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to proxy of Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNamespacedServiceProxyWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect DELETE requests to proxy of Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteConnectCoreV1DeleteNamespacedServiceProxyWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * read status of the specified Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespacedServiceStatus(
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Service');
    }

    /**
     * replace status of the specified Service
     *
     * @param Models\V1Service $body      TODO: type description here
     * @param string           $name      name of the Service
     * @param string           $mnamespace object name and auth scope, such as for teams and projects
     * @param string           $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespacedServiceStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Service');
    }

    /**
     * partially update status of the specified Service
     *
     * @param object $body      TODO: type description here
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $pretty    (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespacedServiceStatus(
        $body,
        $name,
        $mnamespace,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{namespace}/services/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty'    => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Service');
    }

    /**
     * read the specified Namespace
     *
     * @param string $name   name of the Namespace
     * @param bool   $exact  (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                       like 'Namespace'.
     * @param bool   $export (optional) Should this value be exported.  Export strips fields that a user can not
     *                       specify.
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1Namespace(
        $name,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'  => var_export($exact, true),
            'export' => var_export($export, true),
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Namespace');
    }

    /**
     * replace the specified Namespace
     *
     * @param Models\V1Namespace $body   TODO: type description here
     * @param string             $name   name of the Namespace
     * @param string             $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1Namespace(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Namespace');
    }

    /**
     * delete a Namespace
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Namespace
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1Namespace(
        $body,
        $name,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Namespace
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the Namespace
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1Namespace(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Namespace');
    }

    /**
     * replace finalize of the specified Namespace
     *
     * @param Models\V1Namespace $body   TODO: type description here
     * @param string             $name   name of the Namespace
     * @param string             $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespaceFinalize(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{name}/finalize';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Namespace');
    }

    /**
     * read status of the specified Namespace
     *
     * @param string $name   name of the Namespace
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NamespaceStatus(
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Namespace');
    }

    /**
     * replace status of the specified Namespace
     *
     * @param Models\V1Namespace $body   TODO: type description here
     * @param string             $name   name of the Namespace
     * @param string             $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NamespaceStatus(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Namespace');
    }

    /**
     * partially update status of the specified Namespace
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the Namespace
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NamespaceStatus(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/namespaces/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Namespace');
    }

    /**
     * list or watch objects of kind Node
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1Node(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1NodeList');
    }

    /**
     * create a Node
     *
     * @param Models\V1Node $body   TODO: type description here
     * @param string        $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1Node(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Node');
    }

    /**
     * delete collection of Node
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionNode(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified Node
     *
     * @param string $name   name of the Node
     * @param bool   $exact  (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                       like 'Namespace'.
     * @param bool   $export (optional) Should this value be exported.  Export strips fields that a user can not
     *                       specify.
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1Node(
        $name,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'  => var_export($exact, true),
            'export' => var_export($export, true),
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Node');
    }

    /**
     * replace the specified Node
     *
     * @param Models\V1Node $body   TODO: type description here
     * @param string        $name   name of the Node
     * @param string        $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1Node(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Node');
    }

    /**
     * delete a Node
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the Node
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1Node(
        $body,
        $name,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified Node
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the Node
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1Node(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Node');
    }

    /**
     * connect GET requests to proxy of Node
     *
     * @param string $name name of the Node
     * @param string $path (optional) Path is the URL path to use for the current proxy request to node.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNodeProxy(
        $name,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path' => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect PUT requests to proxy of Node
     *
     * @param string $name name of the Node
     * @param string $path (optional) Path is the URL path to use for the current proxy request to node.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateConnectCoreV1PutNodeProxy(
        $name,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path' => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to proxy of Node
     *
     * @param string $name name of the Node
     * @param string $path (optional) Path is the URL path to use for the current proxy request to node.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNodeProxy(
        $name,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path' => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect DELETE requests to proxy of Node
     *
     * @param string $name name of the Node
     * @param string $path (optional) Path is the URL path to use for the current proxy request to node.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteConnectCoreV1DeleteNodeProxy(
        $name,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/proxy';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path' => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect GET requests to proxy of Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getConnectCoreV1GetNodeProxyWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect PUT requests to proxy of Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateConnectCoreV1PutNodeProxyWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect POST requests to proxy of Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createConnectCoreV1PostNodeProxyWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * connect DELETE requests to proxy of Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteConnectCoreV1DeleteNodeProxyWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/proxy/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * read status of the specified Node
     *
     * @param string $name   name of the Node
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1NodeStatus(
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Node');
    }

    /**
     * replace status of the specified Node
     *
     * @param Models\V1Node $body   TODO: type description here
     * @param string        $name   name of the Node
     * @param string        $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1NodeStatus(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Node');
    }

    /**
     * partially update status of the specified Node
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the Node
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1NodeStatus(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/nodes/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Node');
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1PersistentVolumeClaimForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumeclaims';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaimList');
    }

    /**
     * create a PersistentVolumeClaim
     *
     * @param Models\V1PersistentVolumeClaim $body   TODO: type description here
     * @param string                         $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1PersistentVolumeClaimForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumeclaims';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeClaim');
    }

    /**
     * list or watch objects of kind PersistentVolume
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1PersistentVolume(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolumeList');
    }

    /**
     * create a PersistentVolume
     *
     * @param Models\V1PersistentVolume $body   TODO: type description here
     * @param string                    $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1PersistentVolume(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolume');
    }

    /**
     * delete collection of PersistentVolume
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionPersistentVolume(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified PersistentVolume
     *
     * @param string $name   name of the PersistentVolume
     * @param bool   $exact  (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                       like 'Namespace'.
     * @param bool   $export (optional) Should this value be exported.  Export strips fields that a user can not
     *                       specify.
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1PersistentVolume(
        $name,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'  => var_export($exact, true),
            'export' => var_export($export, true),
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolume');
    }

    /**
     * replace the specified PersistentVolume
     *
     * @param Models\V1PersistentVolume $body   TODO: type description here
     * @param string                    $name   name of the PersistentVolume
     * @param string                    $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1PersistentVolume(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolume');
    }

    /**
     * delete a PersistentVolume
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the PersistentVolume
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1PersistentVolume(
        $body,
        $name,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified PersistentVolume
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the PersistentVolume
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1PersistentVolume(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolume');
    }

    /**
     * read status of the specified PersistentVolume
     *
     * @param string $name   name of the PersistentVolume
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1PersistentVolumeStatus(
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolume');
    }

    /**
     * replace status of the specified PersistentVolume
     *
     * @param Models\V1PersistentVolume $body   TODO: type description here
     * @param string                    $name   name of the PersistentVolume
     * @param string                    $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1PersistentVolumeStatus(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolume');
    }

    /**
     * partially update status of the specified PersistentVolume
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the PersistentVolume
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1PersistentVolumeStatus(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/persistentvolumes/{name}/status';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PersistentVolume');
    }

    /**
     * list or watch objects of kind Pod
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1PodForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/pods';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodList');
    }

    /**
     * create a Pod
     *
     * @param Models\V1Pod $body   TODO: type description here
     * @param string       $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1PodForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/pods';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Pod');
    }

    /**
     * list or watch objects of kind PodTemplate
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1PodTemplateForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/podtemplates';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodTemplateList');
    }

    /**
     * create a PodTemplate
     *
     * @param Models\V1PodTemplate $body   TODO: type description here
     * @param string               $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1PodTemplateForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/podtemplates';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1PodTemplate');
    }

    /**
     * proxy GET requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProxyCoreV1GETNamespacedPod(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PUT requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PUTNamespacedPod(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy POST requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createProxyCoreV1POSTNamespacedPod(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy DELETE requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteProxyCoreV1DELETENamespacedPod(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PATCH requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PATCHNamespacedPod(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy GET requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProxyCoreV1GETNamespacedPodWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PUT requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PUTNamespacedPodWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy POST requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createProxyCoreV1POSTNamespacedPodWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy DELETE requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteProxyCoreV1DELETENamespacedPodWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PATCH requests to Pod
     *
     * @param string $name      name of the Pod
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PATCHNamespacedPodWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy GET requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProxyCoreV1GETNamespacedService(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PUT requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PUTNamespacedService(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy POST requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createProxyCoreV1POSTNamespacedService(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy DELETE requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteProxyCoreV1DELETENamespacedService(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PATCH requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PATCHNamespacedService(
        $name,
        $mnamespace
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy GET requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProxyCoreV1GETNamespacedServiceWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PUT requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PUTNamespacedServiceWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy POST requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createProxyCoreV1POSTNamespacedServiceWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy DELETE requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteProxyCoreV1DELETENamespacedServiceWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PATCH requests to Service
     *
     * @param string $name      name of the Service
     * @param string $mnamespace object name and auth scope, such as for teams and projects
     * @param string $path      path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PATCHNamespacedServiceWithPath(
        $name,
        $mnamespace,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'      => $name,
            'namespace' => $mnamespace,
            'path'      => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy GET requests to Node
     *
     * @param string $name name of the Node
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProxyCoreV1GETNode(
        $name
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PUT requests to Node
     *
     * @param string $name name of the Node
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PUTNode(
        $name
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy POST requests to Node
     *
     * @param string $name name of the Node
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createProxyCoreV1POSTNode(
        $name
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy DELETE requests to Node
     *
     * @param string $name name of the Node
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteProxyCoreV1DELETENode(
        $name
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PATCH requests to Node
     *
     * @param string $name name of the Node
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PATCHNode(
        $name
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy GET requests to Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProxyCoreV1GETNodeWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PUT requests to Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PUTNodeWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy POST requests to Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createProxyCoreV1POSTNodeWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy DELETE requests to Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteProxyCoreV1DELETENodeWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * proxy PATCH requests to Node
     *
     * @param string $name name of the Node
     * @param string $path path to the resource
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProxyCoreV1PATCHNodeWithPath(
        $name,
        $path
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/proxy/nodes/{name}/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name' => $name,
            'path' => $path,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * list or watch objects of kind ReplicationController
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1ReplicationControllerForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/replicationcontrollers';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationControllerList');
    }

    /**
     * create a ReplicationController
     *
     * @param Models\V1ReplicationController $body   TODO: type description here
     * @param string                         $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1ReplicationControllerForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/replicationcontrollers';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ReplicationController');
    }

    /**
     * list or watch objects of kind ResourceQuota
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1ResourceQuotaForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/resourcequotas';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuotaList');
    }

    /**
     * create a ResourceQuota
     *
     * @param Models\V1ResourceQuota $body   TODO: type description here
     * @param string                 $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1ResourceQuotaForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/resourcequotas';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ResourceQuota');
    }

    /**
     * list or watch objects of kind Secret
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1SecretForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/secrets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1SecretList');
    }

    /**
     * create a Secret
     *
     * @param Models\V1Secret $body   TODO: type description here
     * @param string          $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1SecretForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/secrets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Secret');
    }

    /**
     * list or watch objects of kind SecurityContextConstraints
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1SecurityContextConstraints(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/securitycontextconstraints';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1SecurityContextConstraintsList');
    }

    /**
     * create SecurityContextConstraints
     *
     * @param Models\V1SecurityContextConstraints $body   TODO: type description here
     * @param string                              $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1SecurityContextConstraints(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/securitycontextconstraints';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1SecurityContextConstraints');
    }

    /**
     * delete collection of SecurityContextConstraints
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1CollectionSecurityContextConstraints(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/securitycontextconstraints';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * read the specified SecurityContextConstraints
     *
     * @param string $name   name of the SecurityContextConstraints
     * @param bool   $exact  (optional) Should the export be exact.  Exact export maintains cluster-specific fields
     *                       like 'Namespace'.
     * @param bool   $export (optional) Should this value be exported.  Export strips fields that a user can not
     *                       specify.
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getReadCoreV1SecurityContextConstraints(
        $name,
        $exact = null,
        $export = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/securitycontextconstraints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'exact'  => var_export($exact, true),
            'export' => var_export($export, true),
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1SecurityContextConstraints');
    }

    /**
     * replace the specified SecurityContextConstraints
     *
     * @param Models\V1SecurityContextConstraints $body   TODO: type description here
     * @param string                              $name   name of the SecurityContextConstraints
     * @param string                              $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateReplaceCoreV1SecurityContextConstraints(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/securitycontextconstraints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1SecurityContextConstraints');
    }

    /**
     * delete SecurityContextConstraints
     *
     * @param Models\V1DeleteOptions $body               TODO: type description here
     * @param string                 $name               name of the SecurityContextConstraints
     * @param integer                $gracePeriodSeconds (optional) The duration in seconds before the object should be
     *                                                   deleted. Value must be non-negative integer. The value zero
     *                                                   indicates delete immediately. If this value is nil, the
     *                                                   default grace period for the specified type will be used.
     *                                                   Defaults to a per object value if not specified. zero means
     *                                                   delete immediately.
     * @param bool                   $orphanDependents   (optional) Deprecated: please use the PropagationPolicy, this
     *                                                   field will be deprecated in 1.7. Should the dependent objects
     *                                                   be orphaned. If true/false, the "orphan" finalizer will be
     *                                                   added to/removed from the object's finalizers list. Either
     *                                                   this field or PropagationPolicy may be set, but not both.
     * @param string                 $propagationPolicy  (optional) Whether and how garbage collection will be
     *                                                   performed. Either this field or OrphanDependents may be set,
     *                                                   but not both. The default policy is decided by the existing
     *                                                   finalizer set in the metadata.finalizers and the resource-
     *                                                   specific default policy.
     * @param string                 $pretty             (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteCoreV1SecurityContextConstraints(
        $body,
        $name,
        $gracePeriodSeconds = null,
        $orphanDependents = null,
        $propagationPolicy = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/securitycontextconstraints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'               => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'gracePeriodSeconds' => $gracePeriodSeconds,
            'orphanDependents'   => var_export($orphanDependents, true),
            'propagationPolicy'  => $propagationPolicy,
            'pretty'             => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'       => 'APIMATIC 2.0',
            'Accept'           => 'application/json',
            'content-type'     => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Status');
    }

    /**
     * partially update the specified SecurityContextConstraints
     *
     * @param object $body   TODO: type description here
     * @param string $name   name of the SecurityContextConstraints
     * @param string $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function patchCoreV1SecurityContextConstraints(
        $body,
        $name,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/securitycontextconstraints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'   => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PATCH, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::patch($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1SecurityContextConstraints');
    }

    /**
     * list or watch objects of kind ServiceAccount
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1ServiceAccountForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/serviceaccounts';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceAccountList');
    }

    /**
     * create a ServiceAccount
     *
     * @param Models\V1ServiceAccount $body   TODO: type description here
     * @param string                  $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1ServiceAccountForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/serviceaccounts';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceAccount');
    }

    /**
     * list or watch objects of kind Service
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listCoreV1ServiceForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/services';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
            'pretty'          => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1ServiceList');
    }

    /**
     * create a Service
     *
     * @param Models\V1Service $body   TODO: type description here
     * @param string           $pretty (optional) If 'true', then the output is pretty printed.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createCoreV1ServiceForAllNamespaces(
        $body,
        $pretty = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/services';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'pretty' => $pretty,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($body));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1Service');
    }

    /**
     * watch individual changes to a list of ConfigMap
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1ConfigMapListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/configmaps';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Endpoints
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1EndpointsListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/endpoints';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Event
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1EventListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/events';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of LimitRange
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1LimitRangeListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/limitranges';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Namespace
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespaceList(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ConfigMap
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedConfigMapList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/configmaps';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind ConfigMap
     *
     * @param string  $name            name of the ConfigMap
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedConfigMap(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/configmaps/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Endpoints
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedEndpointsList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/endpoints';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Endpoints
     *
     * @param string  $name            name of the Endpoints
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedEndpoints(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/endpoints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Event
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedEventList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/events';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Event
     *
     * @param string  $name            name of the Event
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedEvent(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/events/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of LimitRange
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedLimitRangeList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/limitranges';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind LimitRange
     *
     * @param string  $name            name of the LimitRange
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedLimitRange(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/limitranges/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedPersistentVolumeClaimList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind PersistentVolumeClaim
     *
     * @param string  $name            name of the PersistentVolumeClaim
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedPersistentVolumeClaim(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Pod
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedPodList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/pods';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Pod
     *
     * @param string  $name            name of the Pod
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedPod(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/pods/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of PodTemplate
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedPodTemplateList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/podtemplates';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind PodTemplate
     *
     * @param string  $name            name of the PodTemplate
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedPodTemplate(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/podtemplates/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ReplicationController
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedReplicationControllerList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/watch/namespaces/{namespace}/replicationcontrollers';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind ReplicationController
     *
     * @param string  $name            name of the ReplicationController
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedReplicationController(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ResourceQuota
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedResourceQuotaList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/resourcequotas';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind ResourceQuota
     *
     * @param string  $name            name of the ResourceQuota
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedResourceQuota(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Secret
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedSecretList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/secrets';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Secret
     *
     * @param string  $name            name of the Secret
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedSecret(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/secrets/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ServiceAccount
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedServiceAccountList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/serviceaccounts';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind ServiceAccount
     *
     * @param string  $name            name of the ServiceAccount
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedServiceAccount(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.
            '/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Service
     *
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedServiceList(
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/services';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Service
     *
     * @param string  $name            name of the Service
     * @param string  $mnamespace      object name and auth scope, such as for teams and projects
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NamespacedService(
        $name,
        $mnamespace,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{namespace}/services/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            'namespace'       => $mnamespace,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Namespace
     *
     * @param string  $name            name of the Namespace
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1Namespace(
        $name,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/namespaces/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Node
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1NodeList(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/nodes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind Node
     *
     * @param string  $name            name of the Node
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1Node(
        $name,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/nodes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1PersistentVolumeClaimListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/persistentvolumeclaims';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of PersistentVolume
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1PersistentVolumeList(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/persistentvolumes';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind PersistentVolume
     *
     * @param string  $name            name of the PersistentVolume
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1PersistentVolume(
        $name,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/persistentvolumes/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Pod
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1PodListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/pods';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of PodTemplate
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1PodTemplateListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/podtemplates';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ReplicationController
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1ReplicationControllerListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/replicationcontrollers';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ResourceQuota
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1ResourceQuotaListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/resourcequotas';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Secret
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1SecretListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/secrets';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of SecurityContextConstraints
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1SecurityContextConstraintsList(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/securitycontextconstraints';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch changes to an object of kind SecurityContextConstraints
     *
     * @param string  $name            name of the SecurityContextConstraints
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1SecurityContextConstraints(
        $name,
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/securitycontextconstraints/{name}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'name'            => $name,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of ServiceAccount
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1ServiceAccountListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/serviceaccounts';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }

    /**
     * watch individual changes to a list of Service
     *
     * @param string  $fieldSelector   (optional) A selector to restrict the list of returned objects by their fields.
     *                                 Defaults to everything.
     * @param string  $labelSelector   (optional) A selector to restrict the list of returned objects by their labels.
     *                                 Defaults to everything.
     * @param string  $pretty          (optional) If 'true', then the output is pretty printed.
     * @param string  $resourceVersion (optional) When specified with a watch call, shows changes that occur after that
     *                                 particular version of a resource. Defaults to changes from the beginning of
     *                                 history. When specified for list: - if unset, then the result is returned from
     *                                 remote storage based on quorum-read flag; - if it's 0, then we simply return
     *                                 what we currently have in cache, no guarantee; - if set to non zero, then the
     *                                 result is at least as fresh as given rv.
     * @param integer $timeoutSeconds  (optional) Timeout for the list/watch call.
     * @param bool    $watch           (optional) Watch for changes to the described resources and return them as a
     *                                 stream of add, update, and remove notifications. Specify resourceVersion.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getWatchCoreV1ServiceListForAllNamespaces(
        $fieldSelector = null,
        $labelSelector = null,
        $pretty = null,
        $resourceVersion = null,
        $timeoutSeconds = null,
        $watch = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/v1/watch/services';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fieldSelector'   => $fieldSelector,
            'labelSelector'   => $labelSelector,
            'pretty'          => $pretty,
            'resourceVersion' => $resourceVersion,
            'timeoutSeconds'  => $timeoutSeconds,
            'watch'           => var_export($watch, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        $mapper = $this->getJsonMapper();

        return $mapper->mapClass($response->body, 'OpenShiftAPIWithKubernetesLib\\Models\\V1WatchEvent');
    }
}
